// ------------ Notification operations ------------
class notification {
  key thread, user;
  mutable read: boolean;
  timestamp;
}

operation create_notification(name, thread_id: text, usernames: set<text>) {
  val user = user@{ .name == name};
  require(is_signer(user.pubkey));

  val thread = thread@{ .id == thread_id };
  for (username in usernames) {
    val toUser = user@{ .name == username };
    create notification(thread, toUser, false, op_context.last_block_time);
  }
}

operation mark_notifications_since_timestamp_read (name, timestamp) {
  val user = user@{ .name == name};
  require(is_signer(user.pubkey));
  update notification @* { .user == user, .timestamp > timestamp } ( read = true );
}

query get_user_notifications(name) {
  val user = user@{ .name == name};
  return notification @* { .user == user } ( .thread, .read, -sort .timestamp);
}

// ------------ Hashtag operations ------------

class thread_tag {
  key name, thread;
}

operation create_thread_tag(username: text, tags: set<text>, thread_id: text) {
  val user = user@{ .name == username};
  require(is_signer(user.pubkey));

  val thread = thread@{ .id == thread_id};
  for(tag in tags) {
    create thread_tag(name = tag, thread);
  }
}

query get_threads_by_tag(tag: text) {
  return thread_tag @* { .name == tag}
    (id=.thread.id, author=.thread.author.name, parentId=.thread.parent_id, message=.thread.message, -sort timestamp=.thread.timestamp);
}

query get_all_tags() {
  return thread_tag @* {} (.name);
}

// ------------ Thread operations ------------

class thread {
  key id: text;
  index parent_id: text;
  index author: user;
  message: text;
  timestamp;
}

operation create_thread(username: text, id: text, parent_id: text, message: text) {
  val user = user@{ .name == username};
  require(is_signer(user.pubkey));
  val time = op_context.last_block_time;
  log("Storing thread: " + id);
  create thread(id, parent_id, user, message, timestamp=time);
}

query get_all_threads() {
  return thread @* {}
    (.id, author=.author.name, parentId=.parent_id, .message, -sort .timestamp);
}

query get_sub_threads(parent_id: text) {
  return thread@*{.parent_id == parent_id}(.id, author=.author.name, .message, sort .timestamp);
}

query get_threads_by_user_id(name) {
  return thread@*{user@{.name == name}}(
    .id,
    author=.author.name,
    .message,
    -sort .timestamp);
}

query get_thread_by_id(id: text) {
  return thread@{.id == id}(.id, author=.author.name, .message);
}

// ------------ Thread Star Rateoperations ------------

class thread_star_rate {
  key id: text, user: user;
}

operation star_rate_thread(username: text, id: text) {
  val user = user@{ .name == username };
  require(is_signer(user.pubkey));
  create thread_star_rate(id, user);
}

operation remove_star_rate_thread(username: text, id: text) {
  val user = user@{ .name == username };
  require(is_signer(user.pubkey));
  delete thread_star_rate @ {.id == id, .user == user};
}

query get_star_rating_for_id(id: text) {
  return thread_star_rate@*{ .id == id }(thread_star_rate.user.name);
}

// ------------ User operations ------------

class user {
  key name;
  password: text;
  index pubkey;
  encryptedPrivKey: text;
  registered: timestamp;
}

operation register_user(name, password: text, pubkey, encryptedPrivKey: text) {
  val admin = "admin";
  if (name == admin) {
    require(is_signer(pubkey));
    create user(name=admin, password=password, pubkey, encryptedPrivKey, op_context.last_block_time);
  } else {
    require(is_signer(user@{ .name == admin }(.pubkey)));
    create user(name=name, password=password, pubkey, encryptedPrivKey, op_context.last_block_time);
  }
}

query login(name, password: text) {
  return user@{.name == name, .password == password}(user.encryptedPrivKey);
}
