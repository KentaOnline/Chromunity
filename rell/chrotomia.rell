// ------------ Representative operations ------------
class representative {
    key user, representativePeriodId: text;
}

operation hideThread(username: text, threadId: text) {
    val user = user@{ .name == username };
    require(is_signer(user.pubkey));
    log("User: ", user);

    val currentRepresentativePeriod = representativeElection@{
        .timestamp < op_context.last_block_time
    } ( .id, -sort .timestamp ) limit 1;
    log("Current representative period: ", currentRepresentativePeriod);

    representative@{
        .user == user,
        .representativePeriodId == currentRepresentativePeriod.id
    };

    // Replace while we don't have a mutable index
    val threadToReplace = thread@{ .id == threadId };
    log("Thread to be hidden: ", threadToReplace.id);

    // Delete thread tags created
    delete threadTag@*{ .thread == threadToReplace };
    log("Deleted thread tags for thread: ", threadToReplace.id);

    for (t in thread@*{}) {
        log("Found thread: ", t.id);
    }

    delete threadToReplace;
    log("Deleted thread: ", threadToReplace.id);
    log("Will re-create thread: ", threadToReplace.id);
    create thread(
        .id = threadToReplace.id,
        .rootThreadId = threadToReplace.rootThreadId,
        threadToReplace.author,
        false,
        .message = threadToReplace.message,
        threadToReplace.timestamp
    );
    log("Re-created thread as hidden");
}

query getCurrentRepresentativePeriod(timestamp) {
    return representativeElection@?{ .timestamp < timestamp } ( .id, -sort .timestamp ) limit 1;
}

query getRepresentatives(representativePeriodId: text) {
    return representative@*{
        .representativePeriodId == representativePeriodId
    } ( .user.name );
}

// ------------ Election operations ------------

/*
** Triggers a new election with an identifier, and a timestamp for when it is finished
*/
operation triggerElection(adminUser: text, id: text, timestamp) {
  require(is_signer(admin@{ .user.name == adminUser}( .user.pubkey )));
  log("Created election with id: " + id);
  create representativeElection(id, timestamp, false);
}

operation completeElection(adminUser: text, id: text, representatives: set<text>) {
    require(is_signer(user@{ .name == adminUser }( .pubkey )));

    log("Searching for election with id: " + id);
    update representativeElection@{ .id == id } (completed = true);

    for (representative in representatives) {
        log("Searching for representative user: " + representative);
        val user = user@{ .name == representative };
        create representative(user, id);
    }
}

operation voteForCandidate(voter: name, candidate: name, electionId: text) {
    val user = user@{ .name == voter };
    require(is_signer(user.pubkey));
    create representativeElectionVote(
        user = user,
        candidate = user@{ .name == candidate },
        representativeElection@{ .id == electionId }
    );
}

operation update_vote_for_candidate(voter: name, candidate: name, electionId: text) {
    val user = user@{ .name == voter };
    require(is_signer(user.pubkey));

    val election = representativeElection@{ .id == electionId };
    val election_candidate = representativeElectionCandidate@{
        .representativeElection == election,
        .user == user@{ .name == candidate }
    };

    delete representativeElectionVote@?{
        .user == user,
        .representativeElection == election
    };

    create representativeElectionVote(
        user = user,
        election,
        candidate = user@{ .name == candidate }
    );
}

operation signUpForElection(name, electionId: text) {
    val user = user@{ .name == name };
    require(is_signer(user.pubkey));

    val election = representativeElection@{
        .id == electionId,
        .timestamp > op_context.last_block_time
    };

    create representativeElectionCandidate(election, user);
}

query getElectionVotes(electionId: text) {
    return representativeElectionVote@*{
        .representativeElection == representativeElection@{
            .id == electionId
        }
    } ( .candidate.name );
}

query getElectionCandidates(electionId: text) {
    val election = representativeElection@{ .id == electionId };
    return representativeElectionCandidate @* {
        .representativeElection == election
    } ( .user.name );
}

query getNextElection(timestamp) {
    return representativeElection@?{ .timestamp > timestamp } ( .id, -sort .timestamp ) limit 1;
}

query getUncompletedElection() {
    return representativeElection@?{
        .completed == false
    } ( .id );
}

query getUserVoteInElection(name, electionId: text) {
    return representativeElectionVote@?{
        .user == user@{ .name == name },
        .representativeElection == representativeElection@{ .id == electionId }
    } ( .candidate.name );
}

class representativeElection {
    key id: text;
    index timestamp;
    mutable completed: boolean; // Need index
}

class representativeElectionCandidate {
  key representativeElection, user;
}

class representativeElectionVote {
    key user, representativeElection;
    index candidate: user;
}
