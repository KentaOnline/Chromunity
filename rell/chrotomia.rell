// ------------ Representative operations ------------
class representative {
    key user, representativePeriodId: text;
}

operation hideThread(username: text, threadId: text) {
    val user = user@{ .name == username };
    require(is_signer(user.pubkey));
    log("User: ", user);

    val currentRepresentativePeriod = representativeElection@{
        .timestamp < op_context.last_block_time
    } ( .id, -sort .timestamp ) limit 1;
    log("Current representative period: ", currentRepresentativePeriod);

    representative@{
        .user == user,
        .representativePeriodId == currentRepresentativePeriod.id
    };

    // Replace while we don't have a mutable index
    val threadToReplace = thread@{ .id == threadId };
    log("Thread to be hidden: ", threadToReplace.id);

    // Delete thread tags created
    delete threadTag@*{ .thread == threadToReplace };
    log("Deleted thread tags for thread: ", threadToReplace.id);

    for (t in thread@*{}) {
        log("Found thread: ", t.id);
    }

    delete threadToReplace;
    log("Deleted thread: ", threadToReplace.id);
    log("Will re-create thread: ", threadToReplace.id);
    create thread(
        .id = threadToReplace.id,
        .rootThreadId = threadToReplace.rootThreadId,
        threadToReplace.author,
        false,
        .message = threadToReplace.message,
        threadToReplace.timestamp
    );
    log("Re-created thread as hidden");
}

query getCurrentRepresentativePeriod(timestamp) {
    return representativeElection@?{ .timestamp < timestamp } ( .id, -sort .timestamp ) limit 1;
}

query getRepresentatives(representativePeriodId: text) {
    return representative@*{
        .representativePeriodId == representativePeriodId
    } ( .user.name );
}

// ------------ Election operations ------------

/*
** Triggers a new election with an identifier, and a timestamp for when it is finished
*/
operation triggerElection(adminUser: text, id: text, timestamp) {
  require(is_signer(admin@{ .user.name == adminUser}( .user.pubkey )));
  log("Created election with id: " + id);
  create representativeElection(id, timestamp, false);
}

operation completeElection(adminUser: text, id: text, representatives: set<text>) {
    require(is_signer(user@{ .name == adminUser }( .pubkey )));

    log("Searching for election with id: " + id);
    update representativeElection@{ .id == id } (completed = true);

    for (representative in representatives) {
        log("Searching for representative user: " + representative);
        val user = user@{ .name == representative };
        create representative(user, id);
    }
}

operation voteForCandidate(voter: name, candidate: name, electionId: text) {
    val user = user@{ .name == voter };
    require(is_signer(user.pubkey));
    create representativeElectionVote(
        user = user,
        candidate = user@{ .name == candidate },
        representativeElection@{ .id == electionId }
    );
}

operation update_vote_for_candidate(voter: name, candidate: name, electionId: text) {
    val user = user@{ .name == voter };
    require(is_signer(user.pubkey));

    val election = representativeElection@{ .id == electionId };
    val election_candidate = representativeElectionCandidate@{
        .representativeElection == election,
        .user == user@{ .name == candidate }
    };

    delete representativeElectionVote@?{
        .user == user,
        .representativeElection == election
    };

    create representativeElectionVote(
        user = user,
        election,
        candidate = user@{ .name == candidate }
    );
}

operation signUpForElection(name, electionId: text) {
    val user = user@{ .name == name };
    require(is_signer(user.pubkey));

    val election = representativeElection@{
        .id == electionId,
        .timestamp > op_context.last_block_time
    };

    create representativeElectionCandidate(election, user);
}

query getElectionVotes(electionId: text) {
    return representativeElectionVote@*{
        .representativeElection == representativeElection@{
            .id == electionId
        }
    } ( .candidate.name );
}

query getElectionCandidates(electionId: text) {
    val election = representativeElection@{ .id == electionId };
    return representativeElectionCandidate @* {
        .representativeElection == election
    } ( .user.name );
}

query getNextElection(timestamp) {
    return representativeElection@?{ .timestamp > timestamp } ( .id, -sort .timestamp ) limit 1;
}

query getUncompletedElection() {
    return representativeElection@?{
        .completed == false
    } ( .id );
}

query getUserVoteInElection(name, electionId: text) {
    return representativeElectionVote@?{
        .user == user@{ .name == name },
        .representativeElection == representativeElection@{ .id == electionId }
    } ( .candidate.name );
}

class representativeElection {
    key id: text;
    index timestamp;
    mutable completed: boolean; // Need index
}

class representativeElectionCandidate {
  key representativeElection, user;
}

class representativeElectionVote {
    key user, representativeElection;
    index candidate: user;
}

// ------------ Following operations ------------
class following {
    key follower: user, follows: user;
}

operation createFollowing(follower: text, follows: text) {
    require(follower != follows);
    val user = user@{ .name == follower };
    require(is_signer(user.pubkey));
    create following(follower = user, follows = user@{ .name == follows });
}

operation removeFollowing(follower: text, follows: text) {
    require(follower != follows);
    val user = user@{ .name == follower };
    require(is_signer(user.pubkey));

    delete following@{ .follower == user, .follows == user@{ .name == follows } };
}

query getUserFollowers(name) {
    return following@*{ .follows == user @ { .name == name} }(.follower.name);
}

query getUserFollows(name) {
    return following@*{ .follower == user@{ .name == name } } ( .follows.name );
}

// ------------ Notification operations ------------
class notification {
    key thread, user;
    mutable read: boolean;
    timestamp;
}

operation createNotification(name, threadId: text, usernames: set<text>) {
    val user = user@{ .name == name };
    require(is_signer(user.pubkey));

    val thread = thread@{ .id == threadId };
    for (username in usernames) {
        val toUser = user@?{ .name == username };
        if (toUser != null) {
            create notification(thread, toUser, false, op_context.last_block_time);
        }
    }
}

operation markNotificationsSinceTimestampRead(name, timestamp) {
    val user = user@{ .name == name };
    require(is_signer(user.pubkey));
    update notification@*{ .user == user, .timestamp > timestamp } ( read = true );
}

query countUnreadUserNotifications(name) {
    val user = user@{ .name == name };
    return notification@*{ .user == user, .read == false } ( id = .thread.id );
}

query getAllUserNotifications(name) {
    val user = user@{ .name == name };
    return notification@*{ .user == user } (
        threadId=.thread.id,
        author=.thread.author.name,
        rootThreadId=.thread.rootThreadId,
        message=.thread.message,
        .read,
        -sort .timestamp
    );
}

// ------------ Hashtag operations ------------

class threadTag {
    key name, thread;
    index timestamp;
}

operation createThreadTag(username: text, tags: set<text>, threadId: text) {
    val user = user@{ .name == username};
    require(is_signer(user.pubkey));

    val thread = thread@{ .id == threadId };
    for(tag in tags) {
    create threadTag(name = tag, thread, op_context.last_block_time);
    }
}

query getThreadsByTagPriorToTimestamp(tag: text, timestamp) {
    return threadTag@*{ 
        .name == tag, 
        .thread.timestamp < timestamp 
    }(
        id=.thread.id,
        author=.thread.author.name,
        rootThreadId=.thread.rootThreadId,
        message=.thread.message,
        -sort timestamp=.thread.timestamp
    );
}

query getAllTags() {
    return threadTag@*{} ( .name );
}

query getTagsSince(timestamp) {
    return threadTag@*{ .timestamp > timestamp }( .name );
}

// ------------ Thread operations ------------

class thread {
    key id: text;
    index rootThreadId: text;
    index author: user;
    index visible: boolean;
    message: text;
    index timestamp;
}

operation createThread(username: text, id: text, rootThreadId: text, message: text) {
    val user = user@{ .name == username };
    require(is_signer(user.pubkey));

    val time = op_context.last_block_time;
    create thread(id, rootThreadId, user, true, message, timestamp=time);
}

query getThreadsAfter(timestamp) {
    return thread @* { 
        .visible == true,
        .timestamp > timestamp
    }(
        .id,
        author=.author.name,
        rootThreadId=.rootThreadId,
        .message,
        -sort .timestamp
    );
}

query getThreadsPriorTo(timestamp) {
    return thread @* { 
        .visible == true,
        .timestamp < timestamp
    }(
        .id,
        author=.author.name,
        rootThreadId=.rootThreadId,
        .message,
        -sort .timestamp
    ) limit 25;
}

query getSubThreads(rootThreadId: text) {
    return thread@*{
        .rootThreadId == rootThreadId,
        .visible == true
    }(
        .id,
        author=.author.name,
        rootThreadId=.rootThreadId,
        .message,
        sort .timestamp
    );
}

query getThreadsByUserIdPriorToTimestamp(name, timestamp) {
    return thread@*{
        user@{ .name == name },
        .visible == true,
        .timestamp < timestamp
    }(
        .id,
        author=.author.name,
        rootThreadId=.rootThreadId,
        .message,
        -sort .timestamp
    );
}

query getThreadById(id: text) {
    return thread@{
        .id == id,
        .visible == true
    }(
        .id,
        author=.author.name,
        rootThreadId=.rootThreadId,
        .message
    );
}

query getThreadByIdIncludingNonVisible(id: text) {
    return thread@{
        .id == id
    }(
        .id,
        author=.author.name,
        rootThreadId=.rootThreadId,
        .message
    );
}

// ------------ Thread Star Rateoperations ------------

class threadStarRate {
    key id: text, user: user;
}

operation starRateThread(username: text, id: text) {
    val user = user@{ .name == username };
    require(is_signer(user.pubkey));
    create threadStarRate(id, user);
}

operation removeStarRateThread(username: text, id: text) {
    val user = user@{ .name == username };
    require(is_signer(user.pubkey));
    delete threadStarRate@{ .id == id, .user == user };
}

query getStarRatingForId(id: text) {
    return threadStarRate@*{ .id == id } ( .user.name );
}

// ------------ User operations ------------

class admin {
    user;
}

class user {
    key name;
    index pubkey;
    registered: integer;
}

operation registerUser(name, pubkey) {
    require(is_signer(pubkey));

    if (name == "admin") {
        val newAdmin = create user(name, pubkey, op_context.transaction.block.block_height);
        create admin(newAdmin);
    } else {
        create user(name, pubkey, op_context.transaction.block.block_height);
    }
}

query getUser(name) {
    return user@{ .name == name } ( .name, .pubkey, .registered );
}
