import election;
import topic;
import user;
import util;

operation remove_topic(username: text, descriptor_id: byte_array, topic_id: text) {
    val user = user.get_verified_user(username, descriptor_id);

    val recent_election = election.representative_election@{ .completed == true } ( .id, @sort_desc .timestamp ) limit 1;
    val representative = representative @{ user, .representative_election.id == recent_election.id };

    val the_topic = topic.topic @{ .id == topic_id };
    
    create topic.topic_moderation(representative.user, the_topic);

    create representative_action(
        id = op_context.transaction.tx_rid,
        representative,
        op_context.last_block_time,
        action = "Topic /t/" + the_topic.id + " was removed by @" + user.display_name
    );
}

operation remove_topic_reply(username: text, descriptor_id: byte_array, topic_reply_id: text) {
    val user = user.get_verified_user(username, descriptor_id);

    val recent_election_id = require(election.get_latest_completed_election_id(), "No election has been held yet");
    val representative = representative @{ user, .representative_election.id == recent_election_id };

    val the_reply = topic.topic_reply @{ .id == topic_reply_id };
    
    create topic.topic_reply_moderation(representative.user, the_reply);

    create representative_action(
        id = op_context.transaction.tx_rid,
        representative,
        op_context.last_block_time,
        action = "Reply in topic /t/" + the_reply.topic.id + " was removed by @" + user.display_name
    );
}

operation suspend_user(username: text, descriptor_id: byte_array, user_to_be_suspended: text) {
    val user = user.get_verified_user(username, descriptor_id);

    val recent_election_id = require(election.get_latest_completed_election_id(), "No election has been held yet");
    val representative = representative @{ user, .representative_election.id == recent_election_id };

    val suspendee = user.user@{ .name == user_to_be_suspended };
    
    val action_id = "suspend_user:" + user_to_be_suspended;
	
	require(
		not is_user_suspended(user, suspendee, op_context.last_block_time), 
		"User already suspended"
	);
	
    val updated_times_suspended = user.user_suspension@*{
    	.user == suspendee,
    	.suspended_by == user
    }( .user ).size() + 1;
    
    val one_day_millis = 86400000;
    val days_suspended = updated_times_suspended * updated_times_suspended;
    val suspension_time_millis = days_suspended * one_day_millis;
	val suspended_until = op_context.last_block_time + suspension_time_millis;

	create user.user_suspension(user = suspendee, suspended_by = user, suspended_until);

    var daysString = " days ";
    if (days_suspended == 1) {
        daysString = " day ";
    }

    create representative_action(
        id = op_context.transaction.tx_rid,
        representative,
        op_context.last_block_time,
        action = "@" + suspendee.display_name + " was suspended for " + days_suspended + daysString +  "by @" + user.display_name
    );
}

operation distrust_representative(name, descriptor_id: byte_array, distrusted: name) {
	val user = user.get_verified_user(name, descriptor_id);
	
	val recent_election_id = require(election.get_latest_completed_election_id(), "No election has been held yet");
    val representative = representative @{ 
    	.user.name == distrusted.lower_case(), 
    	.representative_election.id == recent_election_id
    };
    
    val election_votes = election.representative_election_vote@*{ 
    	.representative_election_candidate.representative_election.id == recent_election_id,
    	.representative_election_candidate.user.name == distrusted.lower_case()
    } ( .user ).size();
    
    val distrusts = representative_distrust@*{ 
    	representative
    }( .distruster ).size();
    
    if (distrusts >= 10 and distrusts >= election_votes) {
    	delete representative;
    } else {
    	create representative_distrust(user, representative);
    }
}

